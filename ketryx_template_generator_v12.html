<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ketryx Template Generator</title>
    <!-- Include docx library from CDN -->
    <script src="https://unpkg.com/docx@7.1.0/build/index.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <script src="config/ketryx_config.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: Inter, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: #f8f8f6; min-height: 100vh; color: #1a3a3a;
        }
        :root {
            --ketryx-teal: #0b4f4f; --ketryx-green: #6fa644; --ketryx-light-green: #8ec63f;
            --ketryx-dark-teal: #1a3a3a; --ketryx-light-gray: #f8fafa; --ketryx-border: #e5e7eb;
            --ketryx-text: #374151; --ketryx-text-light: #6b7280;
        }
        .nav-header { background: white; border-bottom: 1px solid var(--ketryx-border); padding: 16px 24px; display: flex; align-items: center; justify-content: space-between; }
        .logo-text { font-size: 24px; font-weight: 600; color: var(--ketryx-dark-teal); }
        .main-container { max-width: 900px; margin: 0 auto; padding: 48px 24px; }
        .page-title { font-size: 32px; font-weight: 700; color: var(--ketryx-dark-teal); margin-bottom: 12px; line-height: 1.2; }
        .page-subtitle { font-size: 18px; color: var(--ketryx-text-light); margin-bottom: 40px; line-height: 1.6; }
        .progress-container { margin-bottom: 48px; }
        .progress-steps { display: flex; justify-content: space-between; position: relative; }
        .progress-line { position: absolute; top: 20px; left: 0; right: 0; height: 2px; background: var(--ketryx-border); z-index: 0; }
        .progress-line-fill { position: absolute; top: 0; left: 0; height: 100%; background: var(--ketryx-green); transition: width 0.3s ease; }
        .progress-step { position: relative; z-index: 1; display: flex; flex-direction: column; align-items: center; background: #f8f8f6; padding: 0 8px; }
        .progress-dot { width: 40px; height: 40px; border-radius: 50%; background: #f8f8f6; border: 2px solid var(--ketryx-border); display: flex; align-items: center; justify-content: center; font-weight: 600; font-size: 14px; color: var(--ketryx-text-light); transition: all 0.3s ease; }
        .progress-step.active .progress-dot,
        .progress-step.completed .progress-dot { background: var(--ketryx-green); border-color: var(--ketryx-green); color: white; }
        .progress-label { margin-top: 8px; font-size: 12px; color: var(--ketryx-text-light); text-align: center; max-width: 100px; }
        .content-card { background: white; border: 1px solid var(--ketryx-border); border-radius: 12px; padding: 32px; box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1); }
        .question { font-size: 20px; font-weight: 600; color: var(--ketryx-dark-teal); margin-bottom: 24px; line-height: 1.4; }
        .options { display: flex; flex-direction: column; gap: 12px; }
        .option-btn { padding: 16px 20px; border: 1px solid var(--ketryx-border); border-radius: 8px; background: white; cursor: pointer; transition: all 0.2s ease; text-align: left; font-size: 16px; color: var(--ketryx-text); display: flex; align-items: center; gap: 12px; }
        .option-btn:hover { border-color: var(--ketryx-green); background: var(--ketryx-light-gray); }
        .option-btn.selected { border-color: var(--ketryx-green); background: #f0f7ec; color: var(--ketryx-dark-teal); }
        .option-btn.selected::before { content: '✓'; color: var(--ketryx-green); font-weight: bold; margin-left: -4px; }
        .chip-container { display: flex; flex-wrap: wrap; gap: 8px; }
        .chip { padding: 8px 16px; background: var(--ketryx-light-gray); border: 1px solid var(--ketryx-border); border-radius: 20px; font-size: 14px; color: var(--ketryx-text); cursor: pointer; transition: all 0.2s ease; }
        .chip:hover { border-color: var(--ketryx-green); }
        .chip.selected { background: var(--ketryx-green); color: white; border-color: var(--ketryx-green); }
        .input-group { margin-bottom: 20px; }
        .input-group input { width: 100%; padding: 12px 16px; border: 1px solid var(--ketryx-border); border-radius: 8px; font-size: 16px; font-family: inherit; transition: border-color 0.2s ease; background: white; }
        .input-group input:focus { outline: none; border-color: var(--ketryx-green); box-shadow: 0 0 0 3px rgba(111, 166, 68, 0.1); }
        .navigation { display: flex; justify-content: space-between; margin-top: 32px; gap: 12px; }
        .nav-btn { padding: 12px 24px; border-radius: 8px; border: none; cursor: pointer; font-size: 16px; font-weight: 500; transition: all 0.2s ease; font-family: inherit; }
        .nav-btn.back { background: white; color: var(--ketryx-text); border: 1px solid var(--ketryx-border); }
        .nav-btn.back:hover { background: var(--ketryx-light-gray); border-color: var(--ketryx-text-light); }
        .nav-btn.next { background: var(--ketryx-green); color: white; flex-grow: 1; }
        .nav-btn.next:hover { background: #5e8f38; }
        .nav-btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .summary { background: var(--ketryx-light-gray); border-radius: 12px; padding: 24px; margin-bottom: 24px; }
        .summary h3 { color: var(--ketryx-dark-teal); margin-bottom: 20px; font-size: 18px; font-weight: 600; }
        .summary-item { display: flex; justify-content: space-between; padding: 12px 0; border-bottom: 1px solid var(--ketryx-border); }
        .summary-item:last-child { border-bottom: none; }
        .summary-label { color: var(--ketryx-text-light); font-size: 14px; }
        .summary-value { color: var(--ketryx-dark-teal); font-weight: 500; font-size: 14px; }
        .generate-btn { width: 100%; padding: 16px; background: var(--ketryx-green); color: white; border: none; border-radius: 8px; font-size: 16px; font-weight: 600; cursor: pointer; transition: all 0.2s ease; font-family: inherit; }
        .generate-btn:hover { background: #5e8f38; }
        .loading { text-align: center; padding: 48px; }
        .spinner { width: 48px; height: 48px; border: 3px solid var(--ketryx-border); border-top: 3px solid var(--ketryx-green); border-radius: 50%; animation: spin 1s linear infinite; margin: 0 auto 24px; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .success-message { text-align: center; padding: 32px 0; }
        .success-icon { width: 64px; height: 64px; background: var(--ketryx-green); border-radius: 50%; display: flex; align-items: center; justify-content: center; margin: 0 auto 24px; }
        .success-icon::after { content: '✓'; color: white; font-size: 32px; font-weight: bold; }
        .success-message h2 { color: var(--ketryx-dark-teal); font-size: 24px; margin-bottom: 8px; }
        .success-message p { color: var(--ketryx-text-light); font-size: 16px; }
        .template-preview { display: none; }
        .info-box { background: #f0f7ec; border-left: 4px solid var(--ketryx-green); padding: 16px 20px; border-radius: 4px; margin: 24px 0; }
        .info-box strong { color: var(--ketryx-dark-teal); display: block; margin-bottom: 12px; }
        .info-box ol { margin: 0 0 0 20px; color: var(--ketryx-text); line-height: 1.8; }
        @media (max-width: 768px) { .main-container { padding: 24px 16px; } .content-card { padding: 24px 20px; } .progress-label { display: none; } .page-title { font-size: 28px; } }
    </style>
</head>
<body>
    <div class="nav-header">
        <div class="logo-text">Ketryx</div>
        <div style="color: var(--ketryx-text-light); font-size: 14px;">Template Generator</div>
    </div>

    <div class="main-container">
        <h1 class="page-title">Create Your Ketryx Document Template</h1>
        <p class="page-subtitle">Generate custom Word templates that automatically pull data from your Ketryx workspace</p>

        <div class="progress-container" id="progressContainer">
            <div class="progress-steps">
                <div class="progress-line">
                    <div class="progress-line-fill" id="progressFill" style="width: 0%"></div>
                </div>
                <div class="progress-step active" data-step="1">
                    <div class="progress-dot">1</div>
                    <span class="progress-label">Data Sources</span>
                </div>
                <div class="progress-step" data-step="2">
                    <div class="progress-dot">2</div>
                    <span class="progress-label">Filtering</span>
                </div>
                <div class="progress-step" data-step="3">
                    <div class="progress-dot">3</div>
                    <span class="progress-label">Configuration</span>
                </div>
                <div class="progress-step" data-step="4">
                    <div class="progress-dot">4</div>
                    <span class="progress-label">Review</span>
                </div>
            </div>
        </div>

        <div class="content-card" id="content"></div>
    </div>

    <script>
        const templateGenerator = {
            currentStep: 0,
            answers: {},
            currentTemplate: '',
            tableSpecs: [],
            config: null,
            itemTypeIndex: {},
            entityFields: {},
            questionFlow: [],
            filterDefinitions: { basic: [], advanced: [] },

            bootstrapConfiguration() {
                const cfg = window.KetryxTemplateConfig;
                if (!cfg || !Array.isArray(cfg.itemTypes)) {
                    console.error('Missing KetryxTemplateConfig. Please load config/ketryx_config.js before the generator script.');
                    this.config = { itemTypes: [], optionCatalog: {}, filterTypes: { basic: [], advanced: [] } };
                    return;
                }

                this.config = cfg;
                this.filterDefinitions = cfg.filterTypes || { basic: [], advanced: [] };
                this.itemTypeIndex = {};
                this.entityFields = {};

                cfg.itemTypes.forEach(type => {
                    const primaryTypeCode = Array.isArray(type.kql?.typeCodes) && type.kql.typeCodes.length > 0
                        ? type.kql.typeCodes[0]
                        : (type.kql?.typeCode || null);

                    const fields = (type.fields || []).map(field => ({
                        id: field.id,
                        value: field.id,
                        label: field.label,
                        template: field.template,
                        categories: field.categories || [],
                        type: field.type || 'text',
                        meta: field
                    }));

                    const entityDescriptor = {
                        id: type.id,
                        label: type.label,
                        description: type.description || '',
                        kqlType: primaryTypeCode,
                        defaultFields: type.defaultFields || [],
                        supportsCustomFields: Boolean(type.supportsCustomFields),
                        fields
                    };

                    this.itemTypeIndex[type.id] = { config: type, descriptor: entityDescriptor };
                    this.entityFields[type.id] = entityDescriptor;
                });
            },

            buildQuestionFlow() {
                const requirementTypeOptions = [
                    { value: 'intended_use', label: 'Intended Use' },
                    { value: 'user_marketing', label: 'User/Marketing' },
                    { value: 'use_case', label: 'Use Case' },
                    { value: 'functional', label: 'Functional' },
                    { value: 'performance', label: 'Performance' },
                    { value: 'usability', label: 'Usability' },
                    { value: 'other', label: 'Other' }
                ];

                const supportedFilterIds = new Set(['status']);
                const filterTypeOptions = (this.filterDefinitions.basic || [])
                    .filter(filter => supportedFilterIds.has(filter.id))
                    .map(filter => ({ value: filter.id, label: filter.label }));

                return [
                    {
                        id: 'dataSource',
                        question: 'What Ketryx data do you want to include in your document?',
                        type: 'multiselect',
                        condition: () => true,
                        optionsResolver: () => this.getDataSourceOptions()
                    },
                    {
                        id: 'requirementTypes',
                        question: 'Which requirement types do you want to include?',
                        type: 'multiselect',
                        condition: (answers) => answers.dataSource && answers.dataSource.includes('requirements'),
                        options: requirementTypeOptions
                    },
                    {
                        id: 'filtering',
                        question: 'Do you want to filter the data?',
                        type: 'choice',
                        options: [
                            { value: 'yes', label: 'Yes, I want to apply filters' },
                            { value: 'no', label: 'No, include all data' }
                        ]
                    },
                    {
                        id: 'filterType',
                        question: 'What would you like to filter by?',
                        type: 'multiselect',
                        condition: (answers) => answers.filtering === 'yes',
                        options: filterTypeOptions
                    },
                    {
                        id: 'statusFilter',
                        question: 'Select the statuses to include:',
                        type: 'multiselect',
                        condition: (answers) => answers.filterType && answers.filterType.includes('status'),
                        optionsResolver: () => this.getCatalogOptions('statuses')
                    },
                    {
                        id: 'outputFormat',
                        question: 'How should the data be displayed?',
                        type: 'choice',
                        options: [
                            { value: 'table', label: 'Table Format' },
                            { value: 'sections', label: 'Grouped Sections' },
                            { value: 'list', label: 'Bulleted List' },
                            { value: 'mixed', label: 'Mixed Format (Tables + Text)' }
                        ]
                    },
                    {
                        id: 'grouping',
                        question: 'Should items be grouped?',
                        type: 'choice',
                        condition: (answers) => answers.outputFormat === 'sections' || answers.outputFormat === 'mixed',
                        options: [
                            { value: 'type', label: 'Group by Type' },
                            { value: 'status', label: 'Group by Status' },
                            { value: 'priority', label: 'Group by Priority' },
                            { value: 'version', label: 'Group by Version' },
                            { value: 'none', label: 'No Grouping' }
                        ]
                    },
                    {
                        id: 'documentTitle',
                        question: 'What should be the title of your document?',
                        type: 'text',
                        placeholder: 'e.g., Software Requirements Specification'
                    }
                ];
            },

            getDataSourceOptions() {
                const options = Object.values(this.entityFields).map(entity => ({
                    value: entity.id,
                    label: entity.label
                }));
                return options.sort((a, b) => a.label.localeCompare(b.label));
            },

            getCatalogOptions(catalogKey) {
                if (!this.config || !this.config.optionCatalog) return [];
                const entries = this.config.optionCatalog[catalogKey] || [];
                return entries.map(option => ({ value: option.value, label: option.label }));
            },

            resolveQuestionOptions(question) {
                if (typeof question.optionsResolver === 'function') {
                    try { return question.optionsResolver.call(this) || []; }
                    catch (err) { console.error('Failed to resolve options for question', question.id, err); return []; }
                }
                return question.options || [];
            },

            // Step mapping that matches chronological flow
            // 1 Data Sources, 2 Filtering, 3 Configuration, 4 Review
            stepForQuestionId(id) {
                if (id === 'dataSource' || id.endsWith('Fields') || id === 'requirementFields' || id === 'requirementTypes') return 1;
                if (id === 'filtering' || id === 'filterType' || id === 'statusFilter' || id === 'dateRangeFilter') return 2;
                if (id === 'outputFormat' || id === 'grouping' || id === 'documentTitle') return 3;
                return 3;
            },

            // Build start and end indices per step
            getStepBounds(valid) {
                const starts = { 1: -1, 2: -1, 3: -1 };
                const ends = { 1: -1, 2: -1, 3: -1 };
                for (let i = 0; i < valid.length; i++) {
                    const s = this.stepForQuestionId(valid[i].id);
                    if (s < 1 || s > 3) continue;
                    if (starts[s] === -1) starts[s] = i;
                    ends[s] = i;
                }
                return { starts, ends };
            },

            init() {
                this.bootstrapConfiguration();
                this.questionFlow = this.buildQuestionFlow();
                this.loadQuestion();
                this.updateProgressIndicator();
            },

            // Visible, step-weighted, eased progress
            computeVisualProgressPercent(validQuestions) {
                const { starts, ends } = this.getStepBounds(validQuestions);
                const totals = { 1: 0, 2: 0, 3: 0 };
                const answered = { 1: 0, 2: 0, 3: 0 };

                for (let i = 0; i < validQuestions.length; i++) {
                    const s = this.stepForQuestionId(validQuestions[i].id);
                    if (s < 1 || s > 3) continue;
                    totals[s]++;
                    if (i < this.currentStep) answered[s]++;
                }

                const activeSteps = [1,2,3].filter(s => totals[s] > 0);
                if (activeSteps.length === 0) return 0;
                const weight = 100 / activeSteps.length;

                let pct = 0;
                for (const s of [1,2,3]) {
                    if (!totals[s]) continue;
                    const raw = answered[s] / totals[s];
                    let exp = 1.0;
                    if (totals[s] >= 12) exp = 0.5;
                    else if (totals[s] >= 8) exp = 0.6;
                    else if (totals[s] >= 5) exp = 0.75;
                    const eased = Math.pow(raw, exp);
                    pct += eased * weight;
                }

                // Stronger early floor once progress has started
                if (this.currentStep > 0 && pct < 5) pct = 5;
                if (pct > 99.5) pct = 99.5;
                return pct;
            },

            updateProgressIndicator() {
                const valid = this.getValidQuestions();
                const total = valid.length;

                // Determine active step
                let activeStep = 4;
                if (this.currentStep < total) {
                    activeStep = this.stepForQuestionId(valid[this.currentStep].id);
                }

                // Fill
                const progressEl = document.getElementById('progressFill');
                if (this.currentStep >= total) progressEl.style.width = '100%';
                else progressEl.style.width = this.computeVisualProgressPercent(valid).toFixed(2) + '%';

                const steps = document.querySelectorAll('.progress-step');
                const { starts, ends } = this.getStepBounds(valid);

                // Helper to find the first index of the next step
                const nextStart = (s) => {
                    for (let k = s + 1; k <= 3; k++) {
                        if (starts[k] !== -1) return starts[k];
                    }
                    return Infinity;
                };

                steps.forEach((stepEl, idx) => {
                    const s = idx + 1; // 1..4
                    stepEl.classList.remove('active', 'completed');

                    if (s === 4) {
                        if (this.currentStep >= total) stepEl.classList.add('active', 'completed');
                        return;
                    }

                    const hasQs = starts[s] !== -1;
                    const ns = nextStart(s);

                    if (this.currentStep >= total) {
                        stepEl.classList.add('completed');
                        return;
                    }

                    if (!hasQs) {
                        if (activeStep > s) stepEl.classList.add('completed');
                        else if (activeStep === s) stepEl.classList.add('active');
                        return;
                    }

                    // Mark completed as soon as the next step is reached
                    if (this.currentStep >= ns) {
                        stepEl.classList.add('completed');
                    } else if (activeStep === s) {
                        stepEl.classList.add('active');
                    }
                });
            },

            loadQuestion() {
                const question = this.getCurrentQuestion();
                if (!question) { this.showSummary(); return; }

                const content = document.getElementById('content');
                content.innerHTML = '';
                const container = document.createElement('div');
                container.className = 'question-container';

                const questionEl = document.createElement('h2');
                questionEl.className = 'question';
                questionEl.textContent = question.question;
                container.appendChild(questionEl);

                if (question.type === 'choice') {
                    const options = document.createElement('div');
                    options.className = 'options';
                    const optionList = this.resolveQuestionOptions(question);
                    optionList.forEach(option => {
                        const btn = document.createElement('button');
                        btn.className = 'option-btn';
                        btn.innerHTML = option.label;
                        btn.onclick = (e) => { this.selectOption(question.id, option.value, e); };
                        if (this.answers[question.id] === option.value) btn.classList.add('selected');
                        options.appendChild(btn);
                    });
                    container.appendChild(options);
                } else if (question.type === 'multiselect') {
                    const chipContainer = document.createElement('div');
                    chipContainer.className = 'chip-container';
                    const optionList = this.resolveQuestionOptions(question);
                    optionList.forEach(option => {
                        const chip = document.createElement('div');
                        chip.className = 'chip';
                        chip.textContent = option.label;
                        const currentAnswers = this.answers[question.id] || [];
                        if (currentAnswers.includes(option.value)) chip.classList.add('selected');
                        chip.onclick = (e) => this.toggleMultiSelect(question.id, option.value, e);
                        chipContainer.appendChild(chip);
                    });
                    container.appendChild(chipContainer);
                } else if (question.type === 'text') {
                    const inputGroup = document.createElement('div');
                    inputGroup.className = 'input-group';
                    const input = document.createElement('input');
                    input.type = 'text';
                    input.placeholder = question.placeholder || '';
                    input.value = this.answers[question.id] || '';
                    input.oninput = (e) => this.answers[question.id] = e.target.value;
                    inputGroup.appendChild(input);
                    container.appendChild(inputGroup);
                }

                const navigation = document.createElement('div');
                navigation.className = 'navigation';
                if (this.currentStep > 0) {
                    const backBtn = document.createElement('button');
                    backBtn.className = 'nav-btn back';
                    backBtn.textContent = '← Back';
                    backBtn.onclick = () => this.previousQuestion();
                    navigation.appendChild(backBtn);
                }
                const nextBtn = document.createElement('button');
                nextBtn.className = 'nav-btn next';
                nextBtn.textContent = this.currentStep === this.getValidQuestions().length - 1 ? 'Review Template →' : 'Continue →';
                nextBtn.onclick = () => this.nextQuestion();
                if (question.type === 'multiselect') {
                    const values = this.answers[question.id];
                    if (!Array.isArray(values) || values.length === 0) nextBtn.disabled = true;
                } else if (question.type === 'choice' && !this.answers[question.id]) {
                    nextBtn.disabled = true;
                }
                navigation.appendChild(nextBtn);
                container.appendChild(navigation);

                content.appendChild(container);
                this.updateProgressIndicator();
            },

            getCurrentQuestion() { return this.getValidQuestions()[this.currentStep]; },

            getValidQuestions() {
                let questions = [...this.questionFlow];
                if (this.answers.dataSource) {
                    const dataSourceQuestions = [];
                    this.answers.dataSource.forEach(source => {
                        if (this.entityFields[source] && source !== 'requirements') {
                            dataSourceQuestions.push({
                                id: `${source}Fields`,
                                question: `Which ${this.entityFields[source].label.toLowerCase()} fields should appear in your document?`,
                                type: 'multiselect',
                                condition: () => true,
                                options: this.entityFields[source].fields
                            });
                        }
                    });
                    const dataSourceIndex = questions.findIndex(q => q.id === 'dataSource');
                    questions.splice(dataSourceIndex + 1, 0, ...dataSourceQuestions);

                    if (this.answers.dataSource.includes('requirements')) {
                        const reqFieldsQuestion = {
                            id: 'requirementFields',
                            question: 'Which requirement fields should appear in your document?',
                            type: 'multiselect',
                            condition: () => true,
                            options: this.entityFields.requirements.fields
                        };
                        questions.splice(dataSourceIndex + 1, 0, reqFieldsQuestion);
                    }
                }
                return questions.filter(q => !q.condition || q.condition(this.answers));
            },

            selectOption(questionId, value, e) {
                this.answers[questionId] = value;
                document.querySelectorAll('.option-btn').forEach(btn => btn.classList.remove('selected'));
                if (e && e.currentTarget) e.currentTarget.classList.add('selected');
                const nextBtn = document.querySelector('.nav-btn.next');
                if (nextBtn) nextBtn.disabled = false;
            },

            toggleMultiSelect(questionId, value, e) {
                if (!this.answers[questionId]) this.answers[questionId] = [];
                const index = this.answers[questionId].indexOf(value);
                if (index > -1) this.answers[questionId].splice(index, 1);
                else this.answers[questionId].push(value);
                if (e && e.currentTarget) e.currentTarget.classList.toggle('selected');
                const nextBtn = document.querySelector('.nav-btn.next');
                if (nextBtn) nextBtn.disabled = this.answers[questionId].length === 0;
            },

            nextQuestion() {
                const valid = this.getValidQuestions();
                if (this.currentStep < valid.length - 1) { this.currentStep++; this.loadQuestion(); }
                else { this.showSummary(); }
            },

            previousQuestion() { if (this.currentStep > 0) { this.currentStep--; this.loadQuestion(); } },

            showSummary() {
                document.getElementById('progressFill').style.width = '100%';
                document.querySelectorAll('.progress-step').forEach(step => { step.classList.remove('active'); step.classList.add('completed'); });
                const content = document.getElementById('content');
                content.innerHTML = `
                    <div class="summary">
                        <h3>Template Configuration Summary</h3>
                        ${this.generateSummaryHTML()}
                    </div>
                    <button class="generate-btn" onclick="templateGenerator.generateTemplate()">Generate Word Document (.docx)</button>
                    <p style="text-align: center; margin-top: 16px; color: var(--ketryx-text-light); font-size: 14px;">
                        A Word document will be generated with your Ketryx template configuration
                    </p>
                    <div class="navigation">
                        <button class="nav-btn back" onclick="templateGenerator.editAnswers()">← Edit Configuration</button>
                    </div>`;
            },

            generateSummaryHTML() {
                const summaryItems = [];
                if (this.answers.dataSource) {
                    const sources = this.answers.dataSource.map(s => this.entityFields[s] ? this.entityFields[s].label : s).join(', ');
                    summaryItems.push(`<div class="summary-item"><span class="summary-label">Data Sources</span><span class="summary-value">${sources}</span></div>`);
                }
                if (this.answers.outputFormat) {
                    const formatQuestion = this.questionFlow.find(q => q.id === 'outputFormat');
                    const formatOptions = formatQuestion ? this.resolveQuestionOptions(formatQuestion) : [];
                    const format = formatOptions.find(o => o.value === this.answers.outputFormat);
                    const formatLabel = format ? format.label : this.answers.outputFormat;
                    summaryItems.push(`<div class="summary-item"><span class="summary-label">Output Format</span><span class="summary-value">${formatLabel}</span></div>`);
                }
                if (this.answers.filtering) {
                    summaryItems.push(`<div class="summary-item"><span class="summary-label">Filtering</span><span class="summary-value">${this.answers.filtering === 'yes' ? 'Enabled' : 'Disabled'}</span></div>`);
                }
                if (this.answers.documentTitle) {
                    summaryItems.push(`<div class="summary-item"><span class="summary-label">Document Title</span><span class="summary-value">${this.answers.documentTitle}</span></div>`);
                }
                return summaryItems.join('');
            },

            editAnswers() { this.currentStep = 0; this.answers = this.answers || {}; this.loadQuestion(); },

            async generateTemplate() {
                const content = document.getElementById('content');
                content.innerHTML = `<div class="loading"><div class="spinner"></div><p>Generating your Word document...</p></div>`;
                setTimeout(async () => {
                    this.tableSpecs = [];
                    const templateContent = this.buildTemplateContent();
                    this.currentTemplate = templateContent;
                    await this.createProperWordDocument();
                    content.innerHTML = `
                        <div class="success-message">
                            <div class="success-icon"></div>
                            <h2>Document Generated Successfully</h2>
                            <p>Your Ketryx template has been downloaded as a .docx file</p>
                        </div>
                        <div class="info-box">
                            <strong>✓ Your template is ready to use</strong>
                            <ol>
                                <li>The Word document has been downloaded to your computer</li>
                                <li>Open the document to verify the template formatting</li>
                                <li>Upload the document directly to Ketryx</li>
                                <li>The template will process your data automatically</li>
                            </ol>
                        </div>
                        <button class="nav-btn next" style="width: 100%; margin-top: 24px;" onclick="templateGenerator.reset()">Create Another Template</button>`;
                }, 300);
            },

            buildTemplateContent() {
                let template = '';
                template += `# ${this.answers.documentTitle || 'Ketryx Document'}\n\n`;
                if (this.answers.dataSource) {
                    if (this.answers.dataSource.includes('requirements') && this.answers.requirementTypes) {
                        template += this.buildRequirementsByType();
                    } else if (this.answers.dataSource.includes('requirements')) {
                        template += this.buildEntitySection('requirements');
                    }
                    const otherSources = this.answers.dataSource.filter(s => s !== 'requirements');
                    otherSources.forEach(source => { template += this.buildEntitySection(source); });
                }
                return template;
            },

            buildEntitySection(entityType) {
                const entityInfo = this.entityFields[entityType];
                if (!entityInfo) return '';
                let section = `## ${entityInfo.label}\n\n`;
                section += this.buildKQLQuery(entityType);
                if (this.answers.outputFormat === 'table') section += this.buildEntityTable(entityType);
                else if (this.answers.outputFormat === 'sections' || this.answers.outputFormat === 'mixed') section += this.buildEntitySections(entityType);
                else section += this.buildEntityList(entityType);
                return section + '\n';
            },

            buildKQLQuery(entityType) {
                const entityInfo = this.entityFields[entityType];
                const variableName = entityType.toLowerCase();
                let kql = `{$KQL ${variableName} = type:"${entityInfo.kqlType}"`;
                if (this.answers.filtering === 'yes') {
                    if (this.answers.statusFilter && this.answers.statusFilter.length > 0) {
                        const statusFilters = this.answers.statusFilter.map(s => `status:"${s}"`).join(' OR ');
                        kql += ` AND (${statusFilters})`;
                    }
                }
                kql += '}\n\n';
                return kql;
            },

            registerTable(headers, rowCells) {
                const id = this.tableSpecs.length;
                this.tableSpecs.push({ id, headers: headers.slice(), row: rowCells.slice() });
                return `[[KETRYX_TABLE:${id}]]\n`;
            },

            buildEntityTable(entityType) {
                const fields = this.answers[`${entityType}Fields`] || this.getDefaultFields(entityType);
                const variableName = entityType.toLowerCase();
                const headers = fields.map(f => this.getFieldLabel(entityType, f));
                const rowCells = fields.map((field, index) => {
                    const tmpl = this.getFieldTemplate(entityType, field);
                    if (index === 0) return `{#${variableName}}${tmpl}`;
                    if (index === fields.length - 1) return `${tmpl}{/}`;
                    return tmpl;
                });
                return this.registerTable(headers, rowCells);
            },

            buildEntitySections(entityType) {
                const fields = this.answers[`${entityType}Fields`] || this.getDefaultFields(entityType);
                const variableName = entityType.toLowerCase();
                let sections = '';
                if (this.answers.grouping && this.answers.grouping !== 'none') {
                    sections += `{#${variableName} | sort:'docId' | group:'${this.getGroupField(this.answers.grouping)}'}\n\n`;
                    sections += '### {groupKey || "Unspecified"}\n\n';
                    sections += '{#groupItems}\n';
                    sections += '{~~ . | itemContent:"HEADINGS +1"}\n';
                    sections += '{/}\n\n';
                    sections += '{/}\n';
                } else {
                    sections += `{#${variableName}}\n`;
                    sections += '### {title}\n\n';
                    fields.forEach(field => {
                        const label = this.getFieldLabel(entityType, field);
                        const template = this.getFieldTemplate(entityType, field);
                        const fieldMeta = this.entityFields[entityType]?.fields.find(f => f.value === field);
                        const isRichText = fieldMeta && fieldMeta.type === 'richText';
                        if (isRichText || field === 'description') sections += `${template}\n\n`;
                        else sections += `**${label}:** ${template}\n`;
                    });
                    sections += '\n{/}\n';
                }
                return sections;
            },

            buildEntityList(entityType) {
                const variableName = entityType.toLowerCase();
                let list = `{#${variableName}}\n`;
                list += '- **{title}** ({docId})\n';
                if (this.answers[`${entityType}Fields`] && this.answers[`${entityType}Fields`].includes('description')) {
                    const descTemplate = this.getFieldTemplate(entityType, 'description');
                    list += `  ${descTemplate}\n`;
                }
                list += '{/}\n\n';
                return list;
            },

            buildRequirementsByType() {
                let sections = '';
                const types = this.answers.requirementTypes || [];
                const typeMapping = {
                    'intended_use': { title: 'Intended Use', kql: 'type:RQ and "Requirement type":"Intended use"', variable: 'intendeduse' },
                    'user_marketing': { title: 'User/Marketing', kql: 'type:RQ and "Requirement type":"User/marketing"', variable: 'usermarketing' },
                    'use_case': { title: 'Use Case', kql: 'type:RQ and "Requirement type":"Use case"', variable: 'usecase' },
                    'functional': { title: 'Functional', kql: 'type:RQ and "Requirement type":"Functional"', variable: 'functional' },
                    'performance': { title: 'Performance', kql: 'type:RQ and "Requirement type":"Performance"', variable: 'performance' },
                    'usability': { title: 'Useability', kql: 'type:RQ and "Requirement type":"Useability"', variable: 'useability' },
                    'other': { title: 'Other', kql: 'RQ and not "Requirement type":("Intended use" , "User/marketing", "Use case", "Functional", "Performance", "Useability")', variable: 'other' }
                };
                types.forEach(type => {
                    const t = typeMapping[type];
                    if (!t) return;
                    sections += `{$KQL ${t.variable} = (${t.kql})}\n\n`;
                    sections += `## ${t.title}\n\n`;
                    if (this.answers.outputFormat === 'table') sections += this.buildRequirementsTableForType(t.variable);
                    else sections += this.buildRequirementsSectionsForType(t.variable);
                    sections += '\n';
                });
                return sections;
            },

            buildRequirementsTableForType(variableName) {
                const fields = this.answers.requirementFields || ['id', 'title', 'introducedInVersion', 'description', 'parents', 'riskControl'];
                const headers = fields.map(f => this.getFieldLabel('requirements', f));
                const rowCells = fields.map((f, idx) => {
                    const tmpl = this.getFieldTemplate('requirements', f);
                    if (idx === 0) return `{#${variableName}}${tmpl}`;
                    if (idx === fields.length - 1) return `${tmpl}{/}`;
                    return tmpl;
                });
                return this.registerTable(headers, rowCells);
            },

            buildRequirementsSectionsForType(variableName) {
                let sections = '';
                sections += `{#${variableName}}\n`;
                sections += '### {title}\n\n';
                if (this.answers.requirementFields) {
                    this.answers.requirementFields.forEach(field => {
                        const label = this.getFieldLabel('requirements', field);
                        const template = this.getFieldTemplate('requirements', field);
                        const fieldMeta = this.entityFields.requirements?.fields.find(f => f.value === field);
                        const isRichText = fieldMeta && fieldMeta.type === 'richText';
                        if (isRichText || field === 'description') sections += `${template}\n\n`;
                        else sections += `**${label}:** ${template}\n`;
                    });
                }
                sections += '\n{/}\n';
                return sections;
            },

            getDefaultFields(entityType) {
                const descriptor = this.entityFields[entityType];
                if (descriptor && descriptor.defaultFields && descriptor.defaultFields.length > 0) {
                    return descriptor.defaultFields.slice();
                }
                if (descriptor && descriptor.fields && descriptor.fields.length > 0) {
                    return descriptor.fields.slice(0, Math.min(5, descriptor.fields.length)).map(f => f.value);
                }
                return ['id', 'title', 'status'];
            },

            getFieldLabel(entityType, field) {
                const entityInfo = this.entityFields[entityType];
                if (entityInfo) {
                    const fieldDef = entityInfo.fields.find(f => f.value === field);
                    if (fieldDef) return fieldDef.label;
                }
                return field.charAt(0).toUpperCase() + field.slice(1).replace(/([A-Z])/g, ' $1');
            },

            getFieldTemplate(entityType, field) {
                const entityInfo = this.entityFields[entityType];
                if (!entityInfo) return `{${field}}`;
                const fieldDef = entityInfo.fields.find(f => f.value === field);
                if (fieldDef && fieldDef.template) return fieldDef.template;
                return `{${field}}`;
            },

            getGroupField(grouping) {
                const fields = { 'type': 'fieldValue.Type', 'status': 'status', 'priority': 'fieldValue.Priority', 'version': 'introducedInVersion' };
                return fields[grouping] || 'type';
            },

            async createProperWordDocument() {
                const { Document, Packer, Paragraph, TextRun, Table, TableRow, TableCell, WidthType, AlignmentType, HeadingLevel } = docx;
                const lines = this.currentTemplate.split('\n');
                const children = [];
                const processedKQLs = new Set();

                const mono = (text) => new Paragraph({ children: [new TextRun({ text, font: "Courier New" })] });

                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (!line) { children.push(new Paragraph({ text: '' })); continue; }

                    if (line.startsWith('# ')) { children.push(new Paragraph({ text: line.substring(2), heading: HeadingLevel.HEADING_1 })); continue; }
                    if (line.startsWith('## ')) { children.push(new Paragraph({ text: line.substring(3), heading: HeadingLevel.HEADING_2 })); continue; }
                    if (line.startsWith('### ')) { children.push(new Paragraph({ text: line.substring(4), heading: HeadingLevel.HEADING_3 })); continue; }

                    const tableMarker = line.match(/^\[\[KETRYX_TABLE:(\d+)\]\]$/);
                    if (tableMarker) {
                        const spec = this.tableSpecs[parseInt(tableMarker[1], 10)];
                        if (spec) children.push(this.createDocxTableFromSpec(spec));
                        continue;
                    }

                    if (line.startsWith('{$KQL')) {
                        if (!processedKQLs.has(line)) { processedKQLs.add(line); children.push(mono(line)); }
                        continue;
                    }

                    if (line.startsWith('{#') || line.startsWith('{/') || line.startsWith('{~~') || (line.includes('{') && line.includes('}'))) {
                        children.push(mono(line));
                    } else {
                        children.push(new Paragraph({ text: line }));
                    }
                }

                const doc = new Document({ sections: [{ properties: {}, children }] });
                const blob = await Packer.toBlob(doc);
                const title = this.answers.documentTitle || 'ketryx-template';
                const filename = title.replace(/[^a-z0-9\s-]/gi, '').replace(/\s+/g, '_').toLowerCase();
                saveAs(blob, `${filename}.docx`);
            },

            createDocxTableFromSpec(spec) {
                const { Table, TableRow, TableCell, Paragraph, TextRun, WidthType, AlignmentType } = docx;
                const totalCols = spec.headers.length;
                const colWidth = Math.floor(100 / Math.max(1, totalCols));

                const headerCells = spec.headers.map(h => new TableCell({
                    children: [new Paragraph({ children: [new TextRun({ text: h, bold: true })], alignment: AlignmentType.CENTER })],
                    width: { size: colWidth, type: WidthType.PERCENTAGE }
                }));

                const dataCells = spec.row.map(cellText => new TableCell({
                    children: [new Paragraph({ children: [new TextRun({ text: cellText, font: "Courier New" })] })],
                    width: { size: colWidth, type: WidthType.PERCENTAGE }
                }));

                return new Table({
                    rows: [new TableRow({ children: headerCells }), new TableRow({ children: dataCells })],
                    width: { size: 100, type: WidthType.PERCENTAGE }
                });
            },

            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            },

            reset() { this.currentStep = 0; this.answers = {}; this.currentTemplate = ''; this.tableSpecs = []; this.loadQuestion(); this.updateProgressIndicator(); }
        };

        document.addEventListener('DOMContentLoaded', () => { templateGenerator.init(); });
    </script>
</body>
</html>
