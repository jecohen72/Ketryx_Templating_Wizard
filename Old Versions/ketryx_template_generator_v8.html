<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ketryx Template Generator</title>
    <!-- Include docx library from CDN -->
    <script src="https://unpkg.com/docx@7.1.0/build/index.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: Inter, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: #f8f8f6; min-height: 100vh; color: #1a3a3a;
        }
        :root {
            --ketryx-teal: #0b4f4f; --ketryx-green: #6fa644; --ketryx-light-green: #8ec63f;
            --ketryx-dark-teal: #1a3a3a; --ketryx-light-gray: #f8fafa; --ketryx-border: #e5e7eb;
            --ketryx-text: #374151; --ketryx-text-light: #6b7280;
        }
        .nav-header { background: white; border-bottom: 1px solid var(--ketryx-border); padding: 16px 24px; display: flex; align-items: center; justify-content: space-between; }
        .logo-text { font-size: 24px; font-weight: 600; color: var(--ketryx-dark-teal); }
        .main-container { max-width: 900px; margin: 0 auto; padding: 48px 24px; }
        .page-title { font-size: 32px; font-weight: 700; color: var(--ketryx-dark-teal); margin-bottom: 12px; line-height: 1.2; }
        .page-subtitle { font-size: 18px; color: var(--ketryx-text-light); margin-bottom: 40px; line-height: 1.6; }
        .progress-container { margin-bottom: 48px; }
        .progress-steps { display: flex; justify-content: space-between; position: relative; }
        .progress-line { position: absolute; top: 20px; left: 0; right: 0; height: 2px; background: var(--ketryx-border); z-index: 0; }
        .progress-line-fill { position: absolute; top: 0; left: 0; height: 100%; background: var(--ketryx-green); transition: width 0.3s ease; }
        .progress-step { position: relative; z-index: 1; display: flex; flex-direction: column; align-items: center; background: #f8f8f6; padding: 0 8px; }
        .progress-dot { width: 40px; height: 40px; border-radius: 50%; background: #f8f8f6; border: 2px solid var(--ketryx-border); display: flex; align-items: center; justify-content: center; font-weight: 600; font-size: 14px; color: var(--ketryx-text-light); transition: all 0.3s ease; }
        .progress-step.active .progress-dot,
        .progress-step.completed .progress-dot { background: var(--ketryx-green); border-color: var(--ketryx-green); color: white; }
        .progress-label { margin-top: 8px; font-size: 12px; color: var(--ketryx-text-light); text-align: center; max-width: 100px; }
        .content-card { background: white; border: 1px solid var(--ketryx-border); border-radius: 12px; padding: 32px; box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1); }
        .question { font-size: 20px; font-weight: 600; color: var(--ketryx-dark-teal); margin-bottom: 24px; line-height: 1.4; }
        .options { display: flex; flex-direction: column; gap: 12px; }
        .option-btn { padding: 16px 20px; border: 1px solid var(--ketryx-border); border-radius: 8px; background: white; cursor: pointer; transition: all 0.2s ease; text-align: left; font-size: 16px; color: var(--ketryx-text); display: flex; align-items: center; gap: 12px; }
        .option-btn:hover { border-color: var(--ketryx-green); background: var(--ketryx-light-gray); }
        .option-btn.selected { border-color: var(--ketryx-green); background: #f0f7ec; color: var(--ketryx-dark-teal); }
        .option-btn.selected::before { content: '✓'; color: var(--ketryx-green); font-weight: bold; margin-left: -4px; }
        .chip-container { display: flex; flex-wrap: wrap; gap: 8px; }
        .chip { padding: 8px 16px; background: var(--ketryx-light-gray); border: 1px solid var(--ketryx-border); border-radius: 20px; font-size: 14px; color: var(--ketryx-text); cursor: pointer; transition: all 0.2s ease; }
        .chip:hover { border-color: var(--ketryx-green); }
        .chip.selected { background: var(--ketryx-green); color: white; border-color: var(--ketryx-green); }
        .input-group { margin-bottom: 20px; }
        .input-group input { width: 100%; padding: 12px 16px; border: 1px solid var(--ketryx-border); border-radius: 8px; font-size: 16px; font-family: inherit; transition: border-color 0.2s ease; background: white; }
        .input-group input:focus { outline: none; border-color: var(--ketryx-green); box-shadow: 0 0 0 3px rgba(111, 166, 68, 0.1); }
        .navigation { display: flex; justify-content: space-between; margin-top: 32px; gap: 12px; }
        .nav-btn { padding: 12px 24px; border-radius: 8px; border: none; cursor: pointer; font-size: 16px; font-weight: 500; transition: all 0.2s ease; font-family: inherit; }
        .nav-btn.back { background: white; color: var(--ketryx-text); border: 1px solid var(--ketryx-border); }
        .nav-btn.back:hover { background: var(--ketryx-light-gray); border-color: var(--ketryx-text-light); }
        .nav-btn.next { background: var(--ketryx-green); color: white; flex-grow: 1; }
        .nav-btn.next:hover { background: #5e8f38; }
        .nav-btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .summary { background: var(--ketryx-light-gray); border-radius: 12px; padding: 24px; margin-bottom: 24px; }
        .summary h3 { color: var(--ketryx-dark-teal); margin-bottom: 20px; font-size: 18px; font-weight: 600; }
        .summary-item { display: flex; justify-content: space-between; padding: 12px 0; border-bottom: 1px solid var(--ketryx-border); }
        .summary-item:last-child { border-bottom: none; }
        .summary-label { color: var(--ketryx-text-light); font-size: 14px; }
        .summary-value { color: var(--ketryx-dark-teal); font-weight: 500; font-size: 14px; }
        .generate-btn { width: 100%; padding: 16px; background: var(--ketryx-green); color: white; border: none; border-radius: 8px; font-size: 16px; font-weight: 600; cursor: pointer; transition: all 0.2s ease; font-family: inherit; }
        .generate-btn:hover { background: #5e8f38; }
        .loading { text-align: center; padding: 48px; }
        .spinner { width: 48px; height: 48px; border: 3px solid var(--ketryx-border); border-top: 3px solid var(--ketryx-green); border-radius: 50%; animation: spin 1s linear infinite; margin: 0 auto 24px; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .success-message { text-align: center; padding: 32px 0; }
        .success-icon { width: 64px; height: 64px; background: var(--ketryx-green); border-radius: 50%; display: flex; align-items: center; justify-content: center; margin: 0 auto 24px; }
        .success-icon::after { content: '✓'; color: white; font-size: 32px; font-weight: bold; }
        .success-message h2 { color: var(--ketryx-dark-teal); font-size: 24px; margin-bottom: 8px; }
        .success-message p { color: var(--ketryx-text-light); font-size: 16px; }
        .template-preview { background: var(--ketryx-light-gray); border: 1px solid var(--ketryx-border); border-radius: 8px; padding: 20px; margin: 24px 0; }
        .template-preview-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px; }
        .template-preview pre { background: white; border: 1px solid var(--ketryx-border); border-radius: 4px; padding: 16px; overflow-x: auto; font-family: 'SF Mono', Monaco, 'Courier New', monospace; font-size: 13px; line-height: 1.5; max-height: 400px; overflow-y: auto; color: var(--ketryx-text); }
        .info-box { background: #f0f7ec; border-left: 4px solid var(--ketryx-green); padding: 16px 20px; border-radius: 4px; margin: 24px 0; }
        .info-box strong { color: var(--ketryx-dark-teal); display: block; margin-bottom: 12px; }
        .info-box ol { margin: 0 0 0 20px; color: var(--ketryx-text); line-height: 1.8; }
        @media (max-width: 768px) { .main-container { padding: 24px 16px; } .content-card { padding: 24px 20px; } .progress-label { display: none; } .page-title { font-size: 28px; } }
    </style>
</head>
<body>
    <div class="nav-header">
        <div class="logo-text">Ketryx</div>
        <div style="color: var(--ketryx-text-light); font-size: 14px;">Template Generator</div>
    </div>

    <div class="main-container">
        <h1 class="page-title">Create Your Ketryx Document Template</h1>
        <p class="page-subtitle">Generate custom Word templates that automatically pull data from your Ketryx workspace</p>

        <div class="progress-container" id="progressContainer">
            <div class="progress-steps">
                <div class="progress-line">
                    <div class="progress-line-fill" id="progressFill" style="width: 0%"></div>
                </div>
                <div class="progress-step active" data-step="1">
                    <div class="progress-dot">1</div>
                    <span class="progress-label">Data Sources</span>
                </div>
                <div class="progress-step" data-step="2">
                    <div class="progress-dot">2</div>
                    <span class="progress-label">Configuration</span>
                </div>
                <div class="progress-step" data-step="3">
                    <div class="progress-dot">3</div>
                    <span class="progress-label">Filtering</span>
                </div>
                <div class="progress-step" data-step="4">
                    <div class="progress-dot">4</div>
                    <span class="progress-label">Review</span>
                </div>
            </div>
        </div>

        <div class="content-card" id="content"></div>
    </div>

    <script>
        const templateGenerator = {
            currentStep: 0,
            answers: {},
            currentTemplate: '',
            // Structured table specs used when building the DOCX file
            tableSpecs: [], // [{ id, headers: string[], row: string[] }]

            entityFields: {
                requirements: {
                    label: 'Requirements', kqlType: 'RQ',
                    fields: [
                        { value: 'id', label: 'Requirement ID' },
                        { value: 'title', label: 'Title' },
                        { value: 'description', label: 'Description' },
                        { value: 'type', label: 'Requirement Type' },
                        { value: 'status', label: 'Status' },
                        { value: 'priority', label: 'Priority' },
                        { value: 'parents', label: 'Parent Requirements' },
                        { value: 'children', label: 'Child Requirements' },
                        { value: 'introducedInVersion', label: 'Introduced in Version' },
                        { value: 'obsoleteInVersion', label: 'Obsolete in Version' },
                        { value: 'riskControl', label: 'Risk Control For' },
                        { value: 'regions', label: 'Regions' }
                    ]
                },
                tests: {
                    label: 'Test Cases', kqlType: 'TC',
                    fields: [
                        { value: 'id', label: 'Test Case ID' },
                        { value: 'title', label: 'Title' },
                        { value: 'steps', label: 'Steps' },
                        { value: 'expectedBehavior', label: 'Expected Behavior' },
                        { value: 'testType', label: 'Test Type' },
                        { value: 'testedItems', label: 'Tested Items' },
                        { value: 'status', label: 'Status' },
                        { value: 'introducedInVersion', label: 'Introduced in Version' },
                        { value: 'testEnvironments', label: 'Test Environments' },
                        { value: 'executionResults', label: 'Test Execution Results' }
                    ]
                },
                testExecutions: {
                    label: 'Test Executions', kqlType: 'TE',
                    fields: [
                        { value: 'id', label: 'Test Execution ID' },
                        { value: 'title', label: 'Title' },
                        { value: 'testBeingExecuted', label: 'Test Being Executed' },
                        { value: 'observedBehavior', label: 'Observed Behavior' },
                        { value: 'testResult', label: 'Test Result' },
                        { value: 'foundAnomalies', label: 'Found Anomalies' },
                        { value: 'introducedInVersion', label: 'Version' },
                        { value: 'executedBy', label: 'Executed By' },
                        { value: 'executionDate', label: 'Execution Date' }
                    ]
                },
                risks: {
                    label: 'Risk Items', kqlType: 'RISK',
                    fields: [
                        { value: 'id', label: 'Risk ID' },
                        { value: 'title', label: 'Title' },
                        { value: 'description', label: 'Description' },
                        { value: 'severity', label: 'Severity' },
                        { value: 'probability', label: 'Probability' },
                        { value: 'riskLevel', label: 'Risk Level' },
                        { value: 'mitigation', label: 'Mitigation' },
                        { value: 'riskControlMeasures', label: 'Risk Control Measures' },
                        { value: 'isRiskAcceptable', label: 'Risk Acceptable' },
                        { value: 'introducedInVersion', label: 'Introduced in Version' }
                    ]
                },
                changes: {
                    label: 'Change Requests', kqlType: 'CR',
                    fields: [
                        { value: 'id', label: 'Change Request ID' },
                        { value: 'title', label: 'Title' },
                        { value: 'description', label: 'Description' },
                        { value: 'type', label: 'Change Type' },
                        { value: 'affectedItems', label: 'Affected Items' },
                        { value: 'newItems', label: 'New Items' },
                        { value: 'status', label: 'Status' },
                        { value: 'introducedInVersion', label: 'Introduced in Version' },
                        { value: 'impactScope', label: 'Impact Scope' },
                        { value: 'impactCriticality', label: 'Impact Criticality' }
                    ]
                },
                anomalies: {
                    label: 'Anomalies', kqlType: 'AN',
                    fields: [
                        { value: 'id', label: 'Anomaly ID' },
                        { value: 'title', label: 'Title' },
                        { value: 'description', label: 'Description' },
                        { value: 'environment', label: 'Environment' },
                        { value: 'problemReportType', label: 'Problem Report Type' },
                        { value: 'rootCauseAnalysis', label: 'Root Cause Analysis' },
                        { value: 'affectedItems', label: 'Affected Items' },
                        { value: 'resolvedBy', label: 'Resolved By' },
                        { value: 'impactScope', label: 'Impact Scope' },
                        { value: 'impactCriticality', label: 'Impact Criticality' },
                        { value: 'deferralRationale', label: 'Rationale for Deferring' },
                        { value: 'introducedInVersion', label: 'Found in Version' },
                        { value: 'obsoleteInVersion', label: 'Fixed in Version' }
                    ]
                },
                specifications: {
                    label: 'Software Item Specifications', kqlType: 'SIS',
                    fields: [
                        { value: 'id', label: 'Specification ID' },
                        { value: 'title', label: 'Title' },
                        { value: 'description', label: 'Description' },
                        { value: 'fulfills', label: 'Fulfills Requirements' },
                        { value: 'implementedBy', label: 'Implemented By' },
                        { value: 'status', label: 'Status' },
                        { value: 'introducedInVersion', label: 'Introduced in Version' }
                    ]
                },
                capas: {
                    label: 'CAPAs', kqlType: 'CAPA',
                    fields: [
                        { value: 'id', label: 'CAPA ID' },
                        { value: 'title', label: 'Title' },
                        { value: 'description', label: 'Description' },
                        { value: 'type', label: 'Type (Corrective/Preventive)' },
                        { value: 'affectedItems', label: 'Affected Items' },
                        { value: 'rootCause', label: 'Root Cause' },
                        { value: 'status', label: 'Status' },
                        { value: 'introducedInVersion', label: 'Introduced in Version' }
                    ]
                }
            },

            // UI flow
            questionFlow: [
                {
                    id: 'dataSource',
                    question: 'What Ketryx data do you want to include in your document?',
                    type: 'multiselect',
                    condition: () => true,
                    options: [
                        { value: 'requirements', label: 'Requirements' },
                        { value: 'tests', label: 'Test Cases' },
                        { value: 'testExecutions', label: 'Test Executions' },
                        { value: 'risks', label: 'Risk Items' },
                        { value: 'changes', label: 'Change Requests' },
                        { value: 'anomalies', label: 'Anomalies' },
                        { value: 'specifications', label: 'Software Item Specifications' },
                        { value: 'capas', label: 'CAPAs' }
                    ]
                },
                {
                    id: 'requirementTypes',
                    question: 'Which requirement types do you want to include?',
                    type: 'multiselect',
                    condition: (answers) => answers.dataSource && answers.dataSource.includes('requirements'),
                    options: [
                        { value: 'intended_use', label: 'Intended Use' },
                        { value: 'user_marketing', label: 'User/Marketing' },
                        { value: 'use_case', label: 'Use Case' },
                        { value: 'functional', label: 'Functional' },
                        { value: 'performance', label: 'Performance' },
                        { value: 'usability', label: 'Usability' },
                        { value: 'other', label: 'Other' }
                    ]
                },
                {
                    id: 'filtering',
                    question: 'Do you want to filter the data?',
                    type: 'choice',
                    options: [
                        { value: 'yes', label: 'Yes, I want to apply filters' },
                        { value: 'no', label: 'No, include all data' }
                    ]
                },
                {
                    id: 'filterType',
                    question: 'What would you like to filter by?',
                    type: 'multiselect',
                    condition: (answers) => answers.filtering === 'yes',
                    options: [
                        { value: 'status', label: 'Status (Draft, Approved, etc.)' },
                        { value: 'type', label: 'Type' },
                        { value: 'priority', label: 'Priority Level' },
                        { value: 'version', label: 'Specific Version' },
                        { value: 'dateRange', label: 'Date Range' }
                    ]
                },
                {
                    id: 'statusFilter',
                    question: 'Select the statuses to include:',
                    type: 'multiselect',
                    condition: (answers) => answers.filterType && answers.filterType.includes('status'),
                    options: [
                        { value: 'draft', label: 'Draft' },
                        { value: 'review', label: 'In Review' },
                        { value: 'approved', label: 'Approved' },
                        { value: 'released', label: 'Released' },
                        { value: 'obsolete', label: 'Obsolete' }
                    ]
                },
                {
                    id: 'outputFormat',
                    question: 'How should the data be displayed?',
                    type: 'choice',
                    options: [
                        { value: 'table', label: 'Table Format' },
                        { value: 'sections', label: 'Grouped Sections' },
                        { value: 'list', label: 'Bulleted List' },
                        { value: 'mixed', label: 'Mixed Format (Tables + Text)' }
                    ]
                },
                {
                    id: 'grouping',
                    question: 'Should items be grouped?',
                    type: 'choice',
                    condition: (answers) => answers.outputFormat === 'sections' || answers.outputFormat === 'mixed',
                    options: [
                        { value: 'type', label: 'Group by Type' },
                        { value: 'status', label: 'Group by Status' },
                        { value: 'priority', label: 'Group by Priority' },
                        { value: 'version', label: 'Group by Version' },
                        { value: 'none', label: 'No Grouping' }
                    ]
                },
                {
                    id: 'documentTitle',
                    question: 'What should be the title of your document?',
                    type: 'text',
                    placeholder: 'e.g., Software Requirements Specification'
                }
            ],

            init() { this.loadQuestion(); this.updateProgressIndicator(); },
            updateProgressIndicator() {
                const validQuestions = this.getValidQuestions();
                const totalSteps = 4;
                const currentProgress = Math.min(Math.floor((this.currentStep / validQuestions.length) * totalSteps) + 1, totalSteps);
                document.getElementById('progressFill').style.width = (((this.currentStep + 1) / validQuestions.length) * 100) + '%';
                const steps = document.querySelectorAll('.progress-step');
                steps.forEach((step, index) => {
                    step.classList.remove('active', 'completed');
                    if (index < currentProgress - 1) step.classList.add('completed');
                    else if (index === currentProgress - 1) step.classList.add('active');
                });
            },
            loadQuestion() {
                const question = this.getCurrentQuestion();
                if (!question) { this.showSummary(); return; }
                const content = document.getElementById('content');
                content.innerHTML = '';
                const container = document.createElement('div');
                container.className = 'question-container';
                const questionEl = document.createElement('h2');
                questionEl.className = 'question';
                questionEl.textContent = question.question;
                container.appendChild(questionEl);

                if (question.type === 'choice') {
                    const options = document.createElement('div');
                    options.className = 'options';
                    question.options.forEach(option => {
                        const btn = document.createElement('button');
                        btn.className = 'option-btn';
                        btn.innerHTML = option.label;
                        btn.onclick = (e) => { this.selectOption(question.id, option.value, e); };
                        if (this.answers[question.id] === option.value) btn.classList.add('selected');
                        options.appendChild(btn);
                    });
                    container.appendChild(options);
                } else if (question.type === 'multiselect') {
                    const chipContainer = document.createElement('div');
                    chipContainer.className = 'chip-container';
                    question.options.forEach(option => {
                        const chip = document.createElement('div');
                        chip.className = 'chip';
                        chip.textContent = option.label;
                        const currentAnswers = this.answers[question.id] || [];
                        if (currentAnswers.includes(option.value)) chip.classList.add('selected');
                        chip.onclick = (e) => this.toggleMultiSelect(question.id, option.value, e);
                        chipContainer.appendChild(chip);
                    });
                    container.appendChild(chipContainer);
                } else if (question.type === 'text') {
                    const inputGroup = document.createElement('div');
                    inputGroup.className = 'input-group';
                    const input = document.createElement('input');
                    input.type = 'text';
                    input.placeholder = question.placeholder || '';
                    input.value = this.answers[question.id] || '';
                    input.oninput = (e) => this.answers[question.id] = e.target.value;
                    inputGroup.appendChild(input);
                    container.appendChild(inputGroup);
                }

                const navigation = document.createElement('div');
                navigation.className = 'navigation';
                if (this.currentStep > 0) {
                    const backBtn = document.createElement('button');
                    backBtn.className = 'nav-btn back';
                    backBtn.textContent = '← Back';
                    backBtn.onclick = () => this.previousQuestion();
                    navigation.appendChild(backBtn);
                }
                const nextBtn = document.createElement('button');
                nextBtn.className = 'nav-btn next';
                nextBtn.textContent = this.currentStep === this.getValidQuestions().length - 1 ? 'Review Template →' : 'Continue →';
                nextBtn.onclick = () => this.nextQuestion();
                if (question.type !== 'text' && !this.answers[question.id]) nextBtn.disabled = true;
                navigation.appendChild(nextBtn);
                container.appendChild(navigation);
                content.appendChild(container);
                this.updateProgressIndicator();
            },
            getCurrentQuestion() { return this.getValidQuestions()[this.currentStep]; },
            getValidQuestions() {
                let questions = [...this.questionFlow];
                if (this.answers.dataSource) {
                    const dataSourceQuestions = [];
                    this.answers.dataSource.forEach(source => {
                        if (this.entityFields[source] && source !== 'requirements') {
                            dataSourceQuestions.push({
                                id: `${source}Fields`,
                                question: `Which ${this.entityFields[source].label.toLowerCase()} fields should appear in your document?`,
                                type: 'multiselect',
                                condition: () => true,
                                options: this.entityFields[source].fields
                            });
                        }
                    });
                    const dataSourceIndex = questions.findIndex(q => q.id === 'dataSource');
                    questions.splice(dataSourceIndex + 1, 0, ...dataSourceQuestions);
                    if (this.answers.dataSource.includes('requirements')) {
                        const reqFieldsQuestion = {
                            id: 'requirementFields',
                            question: 'Which requirement fields should appear in your document?',
                            type: 'multiselect',
                            condition: () => true,
                            options: this.entityFields.requirements.fields
                        };
                        questions.splice(dataSourceIndex + 1, 0, reqFieldsQuestion);
                    }
                }
                return questions.filter(q => !q.condition || q.condition(this.answers));
            },
            selectOption(questionId, value, e) {
                this.answers[questionId] = value;
                document.querySelectorAll('.option-btn').forEach(btn => btn.classList.remove('selected'));
                if (e && e.currentTarget) e.currentTarget.classList.add('selected');
                const nextBtn = document.querySelector('.nav-btn.next');
                if (nextBtn) nextBtn.disabled = false;
            },
            toggleMultiSelect(questionId, value, e) {
                if (!this.answers[questionId]) this.answers[questionId] = [];
                const index = this.answers[questionId].indexOf(value);
                if (index > -1) this.answers[questionId].splice(index, 1);
                else this.answers[questionId].push(value);
                if (e && e.currentTarget) e.currentTarget.classList.toggle('selected');
                const nextBtn = document.querySelector('.nav-btn.next');
                if (nextBtn) nextBtn.disabled = this.answers[questionId].length === 0;
            },
            nextQuestion() {
                const valid = this.getValidQuestions();
                if (this.currentStep < valid.length - 1) { this.currentStep++; this.loadQuestion(); }
                else { this.showSummary(); }
            },
            previousQuestion() { if (this.currentStep > 0) { this.currentStep--; this.loadQuestion(); } },
            showSummary() {
                document.getElementById('progressFill').style.width = '100%';
                document.querySelectorAll('.progress-step').forEach(step => { step.classList.remove('active'); step.classList.add('completed'); });
                const content = document.getElementById('content');
                content.innerHTML = `
                    <div class="summary">
                        <h3>Template Configuration Summary</h3>
                        ${this.generateSummaryHTML()}
                    </div>
                    <button class="generate-btn" onclick="templateGenerator.generateTemplate()">Generate Word Document (.docx)</button>
                    <p style="text-align: center; margin-top: 16px; color: var(--ketryx-text-light); font-size: 14px;">
                        A Word document will be generated with your Ketryx template configuration
                    </p>
                    <div class="navigation">
                        <button class="nav-btn back" onclick="templateGenerator.editAnswers()">← Edit Configuration</button>
                    </div>`;
            },
            generateSummaryHTML() {
                const summaryItems = [];
                if (this.answers.dataSource) {
                    const sources = this.answers.dataSource.map(s => this.entityFields[s] ? this.entityFields[s].label : s).join(', ');
                    summaryItems.push(`<div class="summary-item"><span class="summary-label">Data Sources</span><span class="summary-value">${sources}</span></div>`);
                }
                if (this.answers.outputFormat) {
                    const format = this.questionFlow.find(q => q.id === 'outputFormat').options.find(o => o.value === this.answers.outputFormat);
                    summaryItems.push(`<div class="summary-item"><span class="summary-label">Output Format</span><span class="summary-value">${format.label}</span></div>`);
                }
                if (this.answers.filtering) {
                    summaryItems.push(`<div class="summary-item"><span class="summary-label">Filtering</span><span class="summary-value">${this.answers.filtering === 'yes' ? 'Enabled' : 'Disabled'}</span></div>`);
                }
                if (this.answers.documentTitle) {
                    summaryItems.push(`<div class="summary-item"><span class="summary-label">Document Title</span><span class="summary-value">${this.answers.documentTitle}</span></div>`);
                }
                return summaryItems.join('');
            },
            editAnswers() { this.currentStep = 0; this.loadQuestion(); },

            async generateTemplate() {
                const content = document.getElementById('content');
                content.innerHTML = `<div class="loading"><div class="spinner"></div><p>Generating your Word document...</p></div>`;
                setTimeout(async () => {
                    this.tableSpecs = [];
                    const templateContent = this.buildTemplateContent();
                    this.currentTemplate = templateContent;
                    await this.createProperWordDocument();
                    content.innerHTML = `
                        <div class="success-message">
                            <div class="success-icon"></div>
                            <h2>Document Generated Successfully</h2>
                            <p>Your Ketryx template has been downloaded as a .docx file</p>
                        </div>
                        <div class="template-preview">
                            <div class="template-preview-header">
                                <strong>Template Preview</strong>
                            </div>
                            <pre id="templatePreview">${this.escapeHtml(templateContent)}</pre>
                        </div>
                        <div class="info-box">
                            <strong>✓ Your template is ready to use</strong>
                            <ol>
                                <li>The Word document has been downloaded to your computer</li>
                                <li>Open the document to verify the template formatting</li>
                                <li>Upload the document directly to Ketryx</li>
                                <li>The template will process your data automatically</li>
                            </ol>
                        </div>
                        <button class="nav-btn next" style="width: 100%; margin-top: 24px;" onclick="templateGenerator.reset()">Create Another Template</button>`;
                }, 300);
            },

            buildTemplateContent() {
                let template = '';
                template += `# ${this.answers.documentTitle || 'Ketryx Document'}\n\n`;
                if (this.answers.dataSource) {
                    if (this.answers.dataSource.includes('requirements') && this.answers.requirementTypes) {
                        template += this.buildRequirementsByType();
                    } else if (this.answers.dataSource.includes('requirements')) {
                        template += this.buildEntitySection('requirements');
                    }
                    const otherSources = this.answers.dataSource.filter(s => s !== 'requirements');
                    otherSources.forEach(source => { template += this.buildEntitySection(source); });
                }
                return template;
            },

            buildEntitySection(entityType) {
                const entityInfo = this.entityFields[entityType];
                if (!entityInfo) return '';
                let section = `## ${entityInfo.label}\n\n`;
                section += this.buildKQLQuery(entityType);
                if (this.answers.outputFormat === 'table') section += this.buildEntityTable(entityType);
                else if (this.answers.outputFormat === 'sections' || this.answers.outputFormat === 'mixed') section += this.buildEntitySections(entityType);
                else section += this.buildEntityList(entityType);
                return section + '\n';
            },

            buildKQLQuery(entityType) {
                const entityInfo = this.entityFields[entityType];
                const variableName = entityType.toLowerCase();
                let kql = `{$KQL ${variableName} = type:"${entityInfo.kqlType}"`;
                if (this.answers.filtering === 'yes') {
                    if (this.answers.statusFilter && this.answers.statusFilter.length > 0) {
                        const statusFilters = this.answers.statusFilter.map(s => `status:"${s}"`).join(' OR ');
                        kql += ` AND (${statusFilters})`;
                    }
                }
                kql += '}\n\n';
                return kql;
            },

            // Registers a table spec and returns a placeholder marker to insert in the text preview
            registerTable(headers, rowCells) {
                const id = this.tableSpecs.length;
                this.tableSpecs.push({ id, headers: headers.slice(), row: rowCells.slice() });
                return `[[KETRYX_TABLE:${id}]]\n`;
            },

            buildEntityTable(entityType) {
                const fields = this.answers[`${entityType}Fields`] || this.getDefaultFields(entityType);
                const variableName = entityType.toLowerCase();
                // Headers use full labels without truncation
                const headers = fields.map(f => this.getFieldLabel(entityType, f));
                // Row templates
                const rowCells = fields.map((field, index) => {
                    const tmpl = this.getFieldTemplate(entityType, field);
                    if (index === 0) return `{#${variableName}}${tmpl}`;
                    if (index === fields.length - 1) return `${tmpl}{/}`;
                    return tmpl;
                });
                return this.registerTable(headers, rowCells);
            },

            buildEntitySections(entityType) {
                const fields = this.answers[`${entityType}Fields`] || this.getDefaultFields(entityType);
                const variableName = entityType.toLowerCase();
                let sections = '';
                if (this.answers.grouping && this.answers.grouping !== 'none') {
                    sections += `{#${variableName} | sort:'docId' | group:'${this.getGroupField(this.answers.grouping)}'}\n\n`;
                    sections += '### {groupKey || "Unspecified"}\n\n';
                    sections += '{#groupItems}\n';
                    sections += '{~~ . | itemContent:"HEADINGS +1"}\n';
                    sections += '{/}\n\n';
                    sections += '{/}\n';
                } else {
                    sections += `{#${variableName}}\n`;
                    sections += '### {title}\n\n';
                    fields.forEach(field => {
                        const label = this.getFieldLabel(entityType, field);
                        const template = this.getFieldTemplate(entityType, field);
                        if (field === 'description' || /Description/i.test(field)) sections += `{~~ fieldContent.${field}}\n\n`;
                        else sections += `**${label}:** ${template}\n`;
                    });
                    sections += '\n{/}\n';
                }
                return sections;
            },

            buildEntityList(entityType) {
                const variableName = entityType.toLowerCase();
                let list = `{#${variableName}}\n`;
                list += '- **{title}** ({docId})\n';
                if (this.answers[`${entityType}Fields`] && this.answers[`${entityType}Fields`].includes('description')) list += '  {description}\n';
                list += '{/}\n\n';
                return list;
            },

            buildRequirementsByType() {
                let sections = '';
                const types = this.answers.requirementTypes || [];
                const typeMapping = {
                    'intended_use': { title: 'Intended Use', kql: 'type:RQ and "Requirement type":"Intended use"', variable: 'intendeduse' },
                    'user_marketing': { title: 'User/Marketing', kql: 'type:RQ and "Requirement type":"User/marketing"', variable: 'usermarketing' },
                    'use_case': { title: 'Use Case', kql: 'type:RQ and "Requirement type":"Use case"', variable: 'usecase' },
                    'functional': { title: 'Functional', kql: 'type:RQ and "Requirement type":"Functional"', variable: 'functional' },
                    'performance': { title: 'Performance', kql: 'type:RQ and "Requirement type":"Performance"', variable: 'performance' },
                    'usability': { title: 'Useability', kql: 'type:RQ and "Requirement type":"Useability"', variable: 'useability' },
                    'other': { title: 'Other', kql: 'RQ and not "Requirement type":("Intended use" , "User/marketing", "Use case", "Functional", "Performance", "Useability")', variable: 'other' }
                };
                types.forEach(type => {
                    const t = typeMapping[type];
                    if (!t) return;
                    sections += `{$KQL ${t.variable} = (${t.kql})}\n\n`;
                    sections += `## ${t.title}\n\n`;
                    if (this.answers.outputFormat === 'table') sections += this.buildRequirementsTableForType(t.variable);
                    else sections += this.buildRequirementsSectionsForType(t.variable);
                    sections += '\n';
                });
                return sections;
            },

            buildRequirementsTableForType(variableName) {
                const fields = this.answers.requirementFields || ['id', 'title', 'introducedInVersion', 'description', 'parents', 'riskControl'];
                const columnHeaders = {
                    'id': 'Requirement ID',
                    'title': 'Title',
                    'introducedInVersion': 'Introduced in Version',
                    'description': 'Description',
                    'parents': 'Parents',
                    'riskControl': 'Risk Control For'
                };
                const headers = fields.map(f => columnHeaders[f] || f);
                const fieldTemplates = {
                    'id': `{docId}`,
                    'title': '{title}',
                    'introducedInVersion': '{introducedInVersion}',
                    'description': '{~~ fieldContent.Description}',
                    'parents': '{#relations|where:\'name=="has parent"\'}• {other.title} - {other.docId}{/}',
                    'riskControl': '{#relations|where:\'name=="risk-controls"\'}• {other.title} - {other.docId}{/}'
                };
                const rowCells = fields.map((f, idx) => {
                    const tmpl = fieldTemplates[f] || `{${f}}`;
                    if (idx === 0) return `{#${variableName}}${tmpl}`;
                    if (idx === fields.length - 1) return `${tmpl}{/}`;
                    return tmpl;
                });
                return this.registerTable(headers, rowCells);
            },

            buildRequirementsSectionsForType(variableName) {
                let sections = '';
                sections += `{#${variableName}}\n`;
                sections += '### {title}\n\n';
                if (this.answers.requirementFields) {
                    if (this.answers.requirementFields.includes('description')) sections += '**Description:** {~~ fieldContent.Description}\n\n';
                    if (this.answers.requirementFields.includes('type')) sections += '**Type:** {fieldContent.Requirement_type}\n';
                    if (this.answers.requirementFields.includes('status')) sections += '**Status:** {status}\n';
                    if (this.answers.requirementFields.includes('introducedInVersion')) sections += '**Introduced in Version:** {introducedInVersion}\n';
                    if (this.answers.requirementFields.includes('parents')) sections += '**Parents:** {#relations|where:\'name=="has parent"\'}\\n- {other.title}{/}\n';
                    if (this.answers.requirementFields.includes('riskControl')) sections += '**Risk Control For:** {#relations|where:\'name=="risk-controls"\'}\\n- {other.title}{/}\n';
                }
                sections += '\n{/}\n';
                return sections;
            },

            getDefaultFields(entityType) {
                const defaults = {
                    'requirements': ['id', 'title', 'type', 'status'],
                    'tests': ['id', 'title', 'testType', 'testedItems'],
                    'testExecutions': ['id', 'testBeingExecuted', 'testResult', 'introducedInVersion'],
                    'risks': ['id', 'title', 'severity', 'probability', 'riskLevel'],
                    'changes': ['id', 'title', 'type', 'status'],
                    'anomalies': ['id', 'title', 'problemReportType', 'impactCriticality'],
                    'specifications': ['id', 'title', 'fulfills', 'status'],
                    'capas': ['id', 'title', 'type', 'status']
                };
                return defaults[entityType] || ['id', 'title', 'status'];
            },
            getFieldLabel(entityType, field) {
                const entityInfo = this.entityFields[entityType];
                if (entityInfo) {
                    const fieldDef = entityInfo.fields.find(f => f.value === field);
                    if (fieldDef) return fieldDef.label;
                }
                return field.charAt(0).toUpperCase() + field.slice(1).replace(/([A-Z])/g, ' $1');
            },
            getFieldTemplate(entityType, field) {
                const map = {
                    'id': '{docId}', 'title': '{title}', 'status': '{status}',
                    'introducedInVersion': '{introducedInVersion}', 'obsoleteInVersion': '{obsoleteInVersion}',
                    'description': '{~~ fieldContent.Description}',
                    'steps': '{~~ fieldContent.Steps}', 'expectedBehavior': '{~~ fieldContent.Expected_behavior}',
                    'testType': '{fieldContent.Test_type}', 'testedItems': '{#relations|where:\'name=="tests"\'}• {other.title}{/}',
                    'testEnvironments': '{testEnvironments | join:", "}', 'executionResults': '{#testRuns}{statusName}{/}',
                    'testBeingExecuted': '{#relations|where:\'name=="executes"\'}\\n{other.title}{/}',
                    'observedBehavior': '{~~ fieldContent.Observed_behavior}', 'testResult': '{fieldContent.Test_result}',
                    'foundAnomalies': '{#relations|where:\'name=="found-anomalies"\'}• {other.title}{/}',
                    'executedBy': '{executedBy.name}', 'executionDate': '{createdAt | datetime:"yyyy-MM-dd"}',
                    'severity': '{fieldContent.Severity}', 'probability': '{fieldContent.Probability}',
                    'riskLevel': '{fieldContent.Risk_level}', 'mitigation': '{~~ fieldContent.Mitigation}',
                    'riskControlMeasures': '{#relations|where:\'name=="risk-controlled-by"\'}• {other.title}{/}',
                    'isRiskAcceptable': '{isRiskAcceptable}', 'type': '{fieldContent.Change_type}',
                    'affectedItems': '{#relations|where:\'name=="affects"\'}• {other.title}{/}',
                    'newItems': '{#relations|where:\'name=="new-items"\'}• {other.title}{/}',
                    'impactScope': '{fieldContent.Impact_scope}', 'impactCriticality': '{fieldContent.Impact_criticality}',
                    'environment': '{fieldContent.Environment}', 'problemReportType': '{fieldContent.Problem_report_type}',
                    'rootCauseAnalysis': '{~~ fieldContent.Root_cause_analysis}', 'resolvedBy': '{#relations|where:\'name=="resolved-by"\'}• {other.title}{/}',
                    'deferralRationale': '{~~ fieldContent.Rationale_for_deferring_resolution}',
                    'fulfills': '{#relations|where:\'name=="fulfills"\'}• {other.title}{/}',
                    'implementedBy': '{#relations|where:\'name=="implemented-by"\'}• {other.title}{/}',
                    'rootCause': '{~~ fieldContent.Root_cause}',
                    'parents': '{#relations|where:\'name=="has parent"\'}• {other.title} - {other.docId}{/}',
                    'children': '{#relations|where:\'name=="has child"\'}• {other.title} - {other.docId}{/}',
                    'riskControl': '{#relations|where:\'name=="risk-controls"\'}• {other.title} - {other.docId}{/}',
                    'regions': '{regions | join:", "}', 'priority': '{fieldContent.Priority}'
                };
                return map[field] || `{${field}}`;
            },
            getGroupField(grouping) {
                const fields = { 'type': 'fieldValue.Type', 'status': 'status', 'priority': 'fieldValue.Priority', 'version': 'introducedInVersion' };
                return fields[grouping] || 'type';
            },

            async createProperWordDocument() {
                const { Document, Packer, Paragraph, TextRun, Table, TableRow, TableCell, WidthType, AlignmentType, HeadingLevel } = docx;
                const lines = this.currentTemplate.split('\n');
                const children = [];
                const processedKQLs = new Set();

                const mono = (text) => new Paragraph({ children: [new TextRun({ text, font: "Courier New" })] });

                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (!line) { children.push(new Paragraph({ text: '' })); continue; }

                    if (line.startsWith('# ')) {
                        children.push(new Paragraph({ text: line.substring(2), heading: HeadingLevel.HEADING_1 }));
                        continue;
                    }
                    if (line.startsWith('## ')) {
                        children.push(new Paragraph({ text: line.substring(3), heading: HeadingLevel.HEADING_2 }));
                        continue;
                    }
                    if (line.startsWith('### ')) {
                        children.push(new Paragraph({ text: line.substring(4), heading: HeadingLevel.HEADING_3 }));
                        continue;
                    }

                    // Structured table placeholder
                    const tableMarker = line.match(/^\[\[KETRYX_TABLE:(\d+)\]\]$/);
                    if (tableMarker) {
                        const spec = this.tableSpecs[parseInt(tableMarker[1], 10)];
                        if (spec) children.push(this.createDocxTableFromSpec(spec));
                        continue;
                    }

                    // KQL lines appear exactly once
                    if (line.startsWith('{$KQL')) {
                        if (!processedKQLs.has(line)) {
                            processedKQLs.add(line);
                            children.push(mono(line));
                        }
                        continue;
                    }

                    // Any other template or text
                    if (line.startsWith('{#') || line.startsWith('{/') || line.startsWith('{~~') || line.includes('{') && line.includes('}')) {
                        children.push(mono(line));
                    } else {
                        children.push(new Paragraph({ text: line }));
                    }
                }

                const doc = new Document({ sections: [{ properties: {}, children }] });
                const blob = await Packer.toBlob(doc);
                const title = this.answers.documentTitle || 'ketryx-template';
                const filename = title.replace(/[^a-z0-9\s-]/gi, '').replace(/\s+/g, '_').toLowerCase();
                saveAs(blob, `${filename}.docx`);
            },

            createDocxTableFromSpec(spec) {
                const { Table, TableRow, TableCell, Paragraph, TextRun, WidthType, AlignmentType } = docx;
                const totalCols = spec.headers.length;
                const colWidth = Math.floor(100 / Math.max(1, totalCols));

                const headerCells = spec.headers.map(h => new TableCell({
                    children: [new Paragraph({ children: [new TextRun({ text: h, bold: true })], alignment: AlignmentType.CENTER })],
                    width: { size: colWidth, type: WidthType.PERCENTAGE }
                }));

                const dataCells = spec.row.map(cellText => new TableCell({
                    children: [new Paragraph({ children: [new TextRun({ text: cellText, font: "Courier New" })] })],
                    width: { size: colWidth, type: WidthType.PERCENTAGE }
                }));

                return new Table({
                    rows: [new TableRow({ children: headerCells }), new TableRow({ children: dataCells })],
                    width: { size: 100, type: WidthType.PERCENTAGE }
                });
            },

            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            },
            reset() { this.currentStep = 0; this.answers = {}; this.currentTemplate = ''; this.tableSpecs = []; this.loadQuestion(); this.updateProgressIndicator(); }
        };

        document.addEventListener('DOMContentLoaded', () => { templateGenerator.init(); });
    </script>
</body>
</html>